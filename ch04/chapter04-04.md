## 4.4 함수 호출과 this

함수의 기본적인 기능은 당연히 함수를 호출하여 코드를 실행하는 것이다.  
하지만 자바스크립트 언어 자체가 C/C++ 같은 엄격한 문법 체크를 하지 않는 자유로운 특성의 언어이므로 함수 호출 또한 다른 언어와는 달리 자유롭다.  

### 4.4.1 arguments 객체
C와 같은 엄격한 언어와 달리, 자바스크립트에서는 함수를 호출할때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다.
```js
//함수 형식에 맞춰 인자를 넘기지 않더라도 함수 호출이 가능함을 나타내는 예제코드
function func(arg1, arg2){
    console.log(arg1, arg2);
}

func();       //출력값 undefined undefined
func(1);      //출력값 1 undefined
func(1, 2);   //출력값 1 2
func(1, 2, 3);   //출력값 1 2
```
위 예제에서 func(), func(1) 호출처럼 정의된 함수의 인자보다 적게 함수를 호출했을 경우, 넘겨지지 않은 인자에는 **undefined** 값이 할당된다.  
이와 반대로 정의된 인자 개수보다 많게 함수를 호출했을 경우는 에러가 발생하지 않고,  
초과된 인수는 무시된다.

자바스크립트의 이러한 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다.  
이를 가능케 하는 게 바로 **arguments 객체** 다.  
자바스크립트에서는 함수를 호출할 때 인수들과 함계 암묵적으로 arguments 객체가 함수 내부로 전달되기 때문이다.  
arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미한다.  
특이한 점은 이 객체는 실제 배열이 아닌 **유사 배열 객체** 라는 점이다.

```js
//arguments 겍체 예제 코드
// add() 함수
function add(a, b){
    //arguments 객체 출력
    console.dir(arguments);
    return a+b;
}
console.log(add(1));    //출력값 NaN
console.log(add(1, 2)); //출력값 3
console.log(add(1, 2, 3)); //출력값 3
```
앞서 얘기했듯이 arguments는 객체이지 배열이 아니다.  
즉, length 프로퍼티가 있으므로 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용할 경우 에러가 발생한다는 것에 주으해야 한다.  
물론 유사 배열 객체에서 배열 메서드를 사용하는 방법이 있다.  
**call과 apply 메서드를 이용한 명시적인 this 바인딩**

arguments 객체는 매개변수 개수가 정확하게 정해지지 않은 함수를 구현하거나, 전달된 인자의 개수에 따라 서로 다른 처리를 해줘야 하는 함수를 개발하는 데 유용하게 사용할 수 있다.
```js
function sum(){
    var result = 0;

    for(var i = 0; i < arguments.length; i++){
        result += arguments[i];
    }

    return result;
}

console.log(sum(1, 2, 3));                    //출력값 6
console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9));  //출력값 45
```
